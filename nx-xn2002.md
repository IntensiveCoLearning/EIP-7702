---
timezone: UTC+8
---

> 请在上边的 timezone 添加你的当地时区(UTC)，这会有助于你的打卡状态的自动化更新，如果没有添加，默认为北京时间 UTC+8 时区


# 倪响

1. 自我介绍 北京邮电大学大四学生，在 24 年接触并了解到 Web3，对 Web3 技术和理念很感兴趣，希望能够进一步学习 Web3 知识并在未来能够参与到 Web3 生态的建设当中
2. 你认为你会完成本次残酷学习吗？ 会
3. 你的联系方式(推荐 Telegram) @nx_xn2002   1870230468@qq.com

## Notes

<!-- Content_START -->

### 2025.05.14

今天是共学的第一天，我打算先通过粗读 EIP-7702 提案原文，对涉及到的相关概念有一个初步的了解。

首先，在 Abstract 摘要中我了解到，该提案新增了一种交易类型，允许 EOA 在**一笔交易**中通过签名授权某些合约来代理其行为，换句话说，就是使得 EOA 在该交易中**临时拥有执行合约代码的能力**。

在此前的学习中，我了解到以太坊中有两类账户类型：EOA（**Externally Owned Account**，外部拥有账户）和智能合约账户（**Contract Account**）。像我们常用的 MetaMask 等钱包创建的地址，几乎都是 EOA。EOA 具有以下几个特点：

1. 账户中没有可执行的合约代码，不能响应调用，只能主动发起交易
2. 可以向其他账户发送 ETH 或调用合约方法
3. 由用户持有私钥控制，只有持有私钥的人才能发起交易
4. 每次交易需要自行支付 gas 费用

按我的理解，EIP-7702 是因为原本的 EOA 仅能用于签名和发起交易，功能非常有限，而此次提案尝试通过一种类似“代理模式”的方法，让 EOA 在单次交易中“**临时委托**”某个合约地址的代码来代理其执行逻辑，重点在于这种代理仅在该笔交易的生命周期内有效。

因此我总结为一句话：
 **EIP-7702 是一种以“一次交易”为生命周期的、临时性合约代理机制，使 EOA 能在该交易中由指定合约代码代理其行为。**

今天时间有限，我还阅读了 Motivation 动机部分。大致了解到，该提案的动因主要是因为当前 EOA 的设计限制了许多提升用户体验的应用场景。EIP-7702 的设计重点围绕以下三个功能展开：

- 批处理
- 赞助（gas fee abstraction）
- 权限降级（delegated control）

明天我将从这几个功能出发，深入理解其实现方式与潜在应用。

> 保留疑问：我是从后端初入 web3 领域的，据我了解代理模式是扩展现有系统功能的一种常见方法，但为什么以太坊发展至今才尝试引入类似机制对 EOA 进行扩展（或者之前已有类似机制？）是否是由于最初的设计约束，还是出于安全性方面的考虑？希望在后续学习中能逐步找到答案。

### 2025.05.15

今天继续阅读 EIP-7702 提案原文。

延续昨天的内容，我今天进入了 Specification（规范）部分的阅读。提案定义了一种全新的交易类型，称为 **set code transaction**，是基于 EIP-2718（统一交易类型架构）之上的扩展。该交易类型允许 EOA 在发起交易时，携带一个“委托指示器”（delegation indicator），即一段特定格式的合约代码（如 `0xef0100 || address`），用于指定一个代理执行的合约地址。

这一机制的核心变化之一，是修改了 **EIP-3607** 的限制。查阅后发现 EIP-3607 的原意是防止含有代码的账户发起交易，以提升网络安全性。而 EIP-7702 放宽了这一限制，允许具有特定格式（即代理指示器）的代码账户作为合法的交易发送者。虽然这样提升了 EOA 的扩展能力，但也确实引入了更多攻击面，属于在安全性与功能性之间的一种权衡

在 **General design philosophy（设计理念）** 部分，提案作者讨论了代码委托（Code Delegation）的持久性问题。最初的设想是采用临时授权机制：在一笔交易中暂时写入合约代码，执行完毕后立即清除。这种方式相对安全，避免了永久性修改账户状态。但实践中发现，这种设计容易被用户当作脚本引擎使用，而非作为智能钱包的正式升级路径，导致用户体验发展方向割裂：一边是轻量脚本化 EOA，一边是全功能合约钱包。

为统一发展路径，提案后来倾向于采用 **持久化委托** 机制。这样一来，部署成本与复杂度变高，能有效降低滥用的概率，也促使开发者将其视为一种正式的钱包扩展手段，而非临时性的 hack。这种“制造一定摩擦”的策略，是为了防止生态在“智能钱包 vs EOA 脚本”之间产生分裂。

我认为这个权衡很有意思：技术上，临时委托可以更灵活、快速地落地，但长期来看会让系统形态更发散、不统一；而持久化委托虽然牺牲了一定便捷性，却可能促进生态统一走向可维护、安全性更高的方向。

阅读至此，我有一个更明确的感受：**EIP-7702 并不仅仅是为了解决某一个用户操作上的不便，而是在构建一种面向未来的钱包账户形态，在 EOA 与智能合约钱包之间建立“可过渡的中间形态”**，以引导用户逐步迈向合约钱包世界。

明天我准备从提案所提到的实际应用出发，比如批处理、Gas 抽象和权限管理等方面，寻找一些现有代码或 Demo 项目，看看能不能加深理解和思考

> 疑问延续：EIP-7702 的出现是否代表 EOA 的生命周期正在逐渐结束，未来是否所有钱包都将演进为某种形式的智能合约账户？

### 2025.05.17

今天看到群里有朋友讨论 EIP-7702 的一个潜在应用场景：**Social Recovery（社交恢复）**。这是当前智能钱包中常见的一种功能，用于帮助用户在私钥丢失或无法访问账户的情况下，**恢复对账户的控制权**。值得注意的是，这里强调的是“恢复控制权”而非“找回原始私钥”，因为从安全角度出发，私钥应始终保持不可泄露。

结合前几天对 EIP-7702 的学习，我突然意识到：**这项提案本质上为 EOA 引入了“可被代码代理控制”的能力，等于是为传统不可扩展的 EOA 打开了权限恢复的可能性**。原本，一旦用户丢失私钥，EOA 便无法再被控制；但在 7702 中，用户可以预先通过一笔 `set code` 交易，为自己的 EOA 设置一段可代理执行的合约逻辑，从而在合约层面实现权限校验与恢复策略。

以 EIP-7702: A Deep Dive into Smart EOAs with Implementation Examples 中所举的例子为例，常见的恢复机制包括：

- **M-of-N 签名机制**：如 2-of-3 guardian 模式，用户可指定多个可信账户（朋友、设备、服务）共同协助恢复权限
- **ZK-email 验证**：通过 zk 证明用户控制某个邮箱，实现无需暴露隐私信息的权限确认
- **社交图授权**：利用链上社交图谱确定可信关系网络，实现去中心化的恢复流程

这些机制本来只能在智能合约钱包中实现，而 EIP-7702 的出现，使得它们首次成为 EOA 用户的可能选项。

从我的角度来看，EIP-7702 很像一种“分层管理员”的权限架构：

- **EOA 本身类似于超级管理员（root）**，拥有最初的签名权限，可以任意指定或撤销代理合约
- **代理合约则扮演系统管理员（admin）** 的角色，执行日常操作，并内嵌各种权限控制逻辑
- 这样即使用户暂时无法访问超级管理员权限（丢失私钥），只要代理逻辑设置得当，仍有可能通过其他机制恢复访问权

这其实是传统 Web 安全设计中的常见做法，只不过在链上执行，需要在不牺牲去中心化与安全性的前提下完成

当然，**EIP-7702 的开放性也意味着潜在的安全挑战**。一旦用户误授权了一个恶意合约为代理，便可能彻底失去账户控制权。因此我认为：

- 对 `set code` 交易的内容审计至关重要
- 钱包和浏览器层应该在授权代理逻辑时提供更透明的 UI 和合约行为分析
- 用户教育也应同步跟上，避免因轻信而转交控制权

### 2025.05.18

和昨天一样，今天的学习也从群友的技术讨论引发了新的思考。这次引起我注意的话题是关于 EIP-7702 是否能实现 **0gas 账户的可信入场**，以及在这个过程中 `msg.sender` 是否仍然能够正确表示签名者身份的问题。

#### 🧩 起点：7702 能否在 0gas 账户场景中设置正确的 `msg.sender`？

在讨论中，一位群友提出这样一个设想：

> 一个新创建的 0gas 账户，只签署一笔交易但自己没有 Gas，由中继者帮它发送出去，那么合约内读取 `msg.sender` 的话，是否还能识别出是这个账户自己？

这时另一位群友表示支持：

> “7702 就因为改了底层，对这种代理的 call 会设置好对应的 sender，不然做不到批量 approve 什么的。”

这句话引起了我的注意。**按照我以往对以太坊执行逻辑的理解，`msg.sender` 一直都是由最外层的交易调用者决定的**，而如果是由中继者代发交易，`msg.sender` 应该是中继者地址。

于是我带着这个疑问去翻阅了 EIP-7702 提案文档。

#### 🔍 求证：7702 是否“改变了 msg.sender 的语义”？

在 EIP-7702 的 `Security Considerations` 和 `General design philosophy` 部分，我发现了以下几段关键性描述：

> **“Allowing tx.origin to set code and execute its own delegated code enables what is called self-sponsoring...”**

> **“However, that means the EIP breaks the invariant that `msg.sender == tx.origin` only happens in the topmost execution frame of a transaction.”**

> **“This will affect smart contracts containing `require(msg.sender == tx.origin)` style checks.”**

这几句话揭示了一个重要事实：

**EIP-7702 的确改变了传统以太坊中 `msg.sender` 与 `tx.origin` 的关系。**

它允许一个 EOA 在没有任何代码的情况下，发送一笔带有临时代码的交易，并在执行中让这段代码以 EOA 自己的身份执行，从而“欺骗” EVM 把 `msg.sender` 设置为这个 EOA 本人。

也就是说，即便交易是由中继者代为广播，**只要执行了 7702 规范，EVM 会在交易最外层直接执行该 EOA 的代码，因此在合约中看到的 `msg.sender` 就是 EOA 本身**。

这与我之前的理解完全相悖。我原以为 `msg.sender` 总是反映中继人的地址，除非合约中手动读取签名校验。但 EIP-7702 事实上是通过底层的交易处理路径，把这种“自我调用”的语义整合了进来。

#### 🔐 安全影响：为什么这是个破坏性的变化？

提案也指出了这种变更的几个副作用：

> - **Breaks reentrancy guards of the style `require(tx.origin == msg.sender)`**
> - **Breaks protections against atomic sandwich attacks**
> - **Allows EOA to set and execute its own code inline**

虽然这打破了以往某些合约中对 EOA 的静态假设（比如通过 `tx.origin == msg.sender` 来判断发起者是 EOA），但提案认为这些模式本身就不安全或是反模式，**并愿意为此承担这些破坏性变更的代价**。

#### 💡 我的理解：7702 合法“伪造” `msg.sender` 是为了去信任地中继

可以这么理解：

- 🧾 EIP-7702 让 EOA 可以携带“临时代码”，在交易执行期间以自己的身份运行
- 🧬 所以从合约的角度，**msg.sender 就是签名者本人，而不是中继者**
- 🛠 这是为了解决传统代付（meta-transactions）中对 relayer 的信任问题
- 🔐 同时带来了新的合约安全挑战（tx.origin 检查失效、重入控制失效等）

#### 🧠 总结思考

这次讨论让我意识到 EIP-7702 不只是“让 EOA 有了 code”这么简单，它实际上通过改动交易生命周期和 sender 处理逻辑，真正做到了让 **用户以自身身份进行 gasless 交互**，而无需过多信任中继者。

这也许能成为 EOA->AA 演进过程中的关键桥梁，保留地址连续性与用户可读性，又具备合约的高度可编程性。

### 2025.05.19

今天的学习仍然来源于群友在共学过程中的实际动手实验。有人分享了一段基于 EIP-7702 的 Demo，演示了如何用一个有 ETH 的钱包（钱包 A）帮助另一个没有 ETH 的钱包（钱包 B）设置授权合约并执行初始化函数。这段代码让我对 **7702 如何实现 zero-gas onboarding 和身份传递** 有了更直观的理解。

#### 🧪 实验代码：钱包 A 资助 B 的 EIP-7702 交易

以下是群友分享的核心代码：

```
import { privateKeyToAccount } from 'viem/accounts'
import { createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'

const walletA = createWalletClient({
  account: privateKeyToAccount('0x...'), // 有ETH的钱包
  chain: sepolia,
  transport: http(),
})

const walletB = privateKeyToAccount('0x...') // 无ETH的钱包
const delegatedContract = '0x80296F...2Bb'   // 共享的授权合约

// Step 1: A 为 B 签署授权绑定 delegatedContract
const authorization = await walletA.signAuthorization({
  account: walletB,
  contractAddress: delegatedContract,
})

// Step 2: A 发起交易，帮 B 完成代码设置 + 初始化调用
const hash = await walletA.sendTransaction({
  authorizationList: [authorization],
  data: '0x8129fc1c', // initialize() 函数选择器
  to: walletB.address,
})

```

#### 🔍 解构：这段代码到底做了什么？

这个 Demo 实际上完整演示了 EIP-7702 的三大核心能力：

| 能力                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| **zero-gas onboarding** | B 钱包无需持有 ETH，A 可以代发 7702 交易并设定 B 的合约逻辑  |
| **合约初始化**          | `data` 字段调用的是标准的 `initialize()` 逻辑                |
| **sender 身份透传**     | 合约中的 `msg.sender` 是 B（授权账户），而不是 A（中继账户） |



这在传统 EOA 模型中是完全无法做到的。即使使用 meta-transaction 模式，合约也需要自己验证 `signature`，而 7702 则将这种**“信任透传”**嵌入到了交易生命周期的最低层。

#### 🧬 为什么 `msg.sender` 是 B，而不是发起交易的 A？

这再次印证了昨天笔记中提到的一个结论：

> EIP-7702 改变了 EVM 中 `msg.sender` 的推导机制，在满足授权条件下，交易中实际执行的是授权者的逻辑，EVM 自动将 `msg.sender` 设置为授权者本人（即签名者 B），而不是中继者 A。

这个特性非常关键——它意味着我们**无需信任中继者**来传递身份信息，也**无需合约内显式处理签名校验逻辑**，大幅简化了授权钱包和合约调用的开发复杂度。

#### 🔐 安全性与破坏性行为的权衡

与昨天分析一致，这种身份透传能力虽然带来了更强的抽象能力，也打破了以下传统假设：

- `tx.origin == msg.sender` 用于判断 EOA 发起人（已失效）
- `msg.sender` 总是代发人地址（已失效）
- 合约部署前不能调用（已失效）

但 EIP-7702 的设计者显然认为：**这些旧有假设不适合构建可扩展、无许可的钱包入口机制**，必须打破现状，才能为模块化钱包、账户即合约铺平道路。

#### 🧠 总结思考

这个 Demo 让我更加理解了 EIP-7702 的设计意图和实际可行性：

- 它不只是提出一个新的账户绑定方式，而是**重塑了“交易是谁发的”这件事的定义**
- 它让一个无 ETH 的地址，也可以借助他人完成初次上链初始化、绑定合约、调用函数
- `msg.sender` 的“身份欺骗”在这里变成了一种**可信的、自主选择的 delegation 模式**

从传统的 `EOA + MetaTx + relayer` 到现在的 `EOA + code + 7702授权`，这可能正是账户抽象平滑演进的中间态。

### 2025.05.20

今天的学习关注点是 EIP-7702 所引入的**委托合约机制中的访问控制漏洞**，这是一个在任何“以他人身份执行代码”的模型中都必须高度警惕的问题。

#### 🧩 起点：委托合约缺乏访问控制可能导致的安全问题

在一个 7702 风格的 gasless 交互场景中，EOA 用户通过签名授权一段逻辑，在一个“代理合约”中被执行。而今天的讨论案例指出了一个关键风险：

> 如果这个代理合约中没有做好访问权限控制，任何人都可以调用它，**以 EOA 的身份在链上执行任意代码**，造成严重的资产安全威胁。

以下是今天看到的一个最小复现示例：

```
solidity复制编辑// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

contract VulnerableContract {
    function doSomething(bytes memory _data, address _to, uint _value) public payable {
        (bool success, ) = _to.call{value: _value}(_data);
        require(success);
    }
}
```

这份合约中，`doSomething` 函数允许**任何调用者**传入任意的 `_data` 和目标地址 `_to`，然后直接通过 `call` 执行。这种结构在传统合约中已经是一个典型的危险模式，而在 EIP-7702 的上下文中，问题更为致命：

> **攻击者可以向这个函数发送带有合约调用数据的交易，从而代替任何关联的 EOA 用户执行转账、操作状态等敏感操作。**

#### 🔍 实验验证：确实可以用这种方式调用任意合约函数

为了验证这个问题，示例中还提供了一个简单的目标合约：

```
solidity复制编辑contract A {
    uint public a;

    function increment(uint256 number) public {
        a += number;
    }
}
```

我们可以通过以下调用实现跨合约调用，甚至无需目标合约本身做任何授权处理：

- `_to`: 合约 `A` 的地址
- `_data`: `increment(10)` 的函数选择器与参数编码：
   `0x7cf5dab0000000000000000000000000000000000000000000000000000000000000000a`

执行 `doSomething` 后，合约 A 中变量 `a` 的值成功被增加了 10。这个例子充分说明了：

> **只要委托合约缺乏对调用者身份的验证，攻击者就可以利用它在链上为所欲为。**

#### 🔐 安全影响：EIP-7702 引入强大能力，也带来了强烈安全假设变化

在传统 EOA 模式下，合约可以默认认为 `msg.sender` 是“唯一且可信”的用户身份。但在 7702 之后：

- 合约调用路径可以被临时代码劫持
- 签名者身份可能被滥用执行任意 call
- 如果代理合约不做签名校验或访问控制，会**扩大攻击面**

这与昨天的笔记中提到的 **msg.sender “合法伪造”** 是一体两面 —— 它为去信任中继带来了便利，也极大放宽了对“交易发起者”的安全假设。

#### 💡 我的理解：EIP-7702 开启了“合约式 EOA”，也带来了合约式的攻击面

从今天的案例我得出一个重要结论：

- ✅ EIP-7702 让 EOA 拥有了像合约一样的行为能力
- ⚠️ 但也要求开发者具备构建合约的安全意识，特别是：
  - 委托合约必须验证签名
  - 必须限制“谁”可以发起交易调用
  - 建议设置合理的权限模型与合约防火墙

#### 🧠 总结思考

今天的例子虽然简短，却再次强调了一个 Web3 安全的核心原则：

> **赋予账户能力的同时，必须建立对应的控制机制。**

EIP-7702 带来了身份与代码的融合，但随之而来的风险也更加接近“合约世界”的复杂度。**开发者不能再把“账户是安全的”当作默认前提，必须从合约角度重新审视账户的每一次行为**

### 2025.05.21

今天在看完大部分 EIP-7702 共学资料后，仍觉得对提案的来龙去脉不够清晰。为了补全背景，我回头学习了早期的 EIP-86。

EIP-86 是 Vitalik 在 2017 年提出的账户抽象提案，核心思想是让用户通过合约验证签名，实现“合约即账户”，可看作是账户抽象的最早尝试。虽然由于与现有架构不兼容最终被搁置，但它的设计理念直接影响了后来的 4337 和 7702。

通过学习 EIP-86，我更清楚地理解了 7702 想解决的问题：在不放弃 EOA 的前提下，引入更灵活的合约行为。这种“回退式合约账户”的设计，某种程度上是对 EIP-86 理想的一种现实妥协。

<!-- Content_END -->
